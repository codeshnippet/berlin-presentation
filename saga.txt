0: Into: I prepared two short (15 min) presentations based on two talks at WebDevCon 2017.
I found inspiring, and would like to share their ideas with you. Lets start with the first one.

1: Presentation will (traditionally) be divided into 3 parts: What? Why? and How?
Lets start with 'What'? And the answer is, good code.
What is good code?

2: In my opinion, good code is: easy to understand, easy to extend, easy to maintain.
- (Understand) Code has to be simple, for others to read: colleagues, new-comers, yourself in half a year.
- (Extend) It is often possible to predict how functionality will extend and create extension points for that.
- (Maintain) Code has to be covered with tests and documented. Ideally tests will serve as documentation for the code.

3:





Before we dive into part one I would like to ask you if you have an answer to following question:
- How good is our code?
You may say: "Quite good" or "OK".
But how can you reason about it? What is "good", what is "ok"?

2:
Sonarqube has an answer.

3:
Because Sonarqube gives you numbers. And with numbers taking about quality becomes so much easier.
Those numbers are: complexity, code coverage, issues count and so on.

4:
"So what?" You ask. "Why should we care?"
Good code or bad code, what matters is if it brings business value, right?
Exactly! The most important thing is the business value.
And business value goes hand in hand with cost.
Producing bad code is cheaper for short projects, but very expensive for long lasting projects.
And here's why:

5:
Imagine a complex piece of code, not covered with tests, not modularized, not abstract.

believe me, that code contains more bugs.
But the worst part is fixing them:
 - Root cause is hard to find.
 - Changing complicated code is hard too.
 - In case there was low test coverage, there's a risk that your change broke something else.
 - And there's no-one left to tell you how its supposed to work, because everyone got depressed and left the project.
 - That is expensive.

Hard to extend:
 - Adding a feature takes longer because code is not abstract and is hard to extend. No extension points were designed.
 - That is expensive.

 Bad code is depressing:
 - Nobody wants to deal with it. People leave the project.
 - And that is very expensive.
